PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE `Comment` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `body` varchar(255) NOT NULL
,  `post_id` integer DEFAULT NULL
,  `parent_comment_id` integer DEFAULT NULL
,  `date` datetime NOT NULL DEFAULT current_timestamp
,  `edited` integer NOT NULL DEFAULT '0'
,  `commenter_id` varchar(255) NOT NULL
);
CREATE TABLE `CommentReaction` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `type` varchar(255) NOT NULL
,  `comment_id` integer NOT NULL
,  `user_id` varchar(255) NOT NULL
,  UNIQUE (`user_id`,`type`,`comment_id`)
);
INSERT INTO CommentReaction VALUES(7,'upVote',14,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386');
INSERT INTO CommentReaction VALUES(28,'upVote',16,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386');
INSERT INTO CommentReaction VALUES(29,'upsideDown',16,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386');
CREATE TABLE `Connection` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `user_id` varchar(255) NOT NULL
,  `connection_id` varchar(255) NOT NULL
,  `post_id` integer DEFAULT NULL
);
CREATE TABLE `Post` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `title` varchar(255) NOT NULL
,  `subtitle` varchar(255) DEFAULT NULL
,  `body` text NOT NULL
,  `banner_photo` varchar(255) DEFAULT NULL
,  `date` datetime NOT NULL DEFAULT current_timestamp
,  `published` integer NOT NULL
,  `category` varchar(255) DEFAULT NULL
,  `author_id` varchar(255) NOT NULL
,  `reads` integer NOT NULL DEFAULT '0'
,  `attachments` text
,  UNIQUE (`title`)
);
INSERT INTO Post VALUES(1,'Weave_pt.1','Websockets',replace('<h3>Part 1. <em>Getting Connected</em></h3><p>WebSockets are used for various interactions.</p><p>To start: the WebSocket is a AWS lambda WebSocket, and as with everything in the development of Weave, uses typescript.</p><p>first here is thee WebSocket side code:</p><p></p><hr><pre><code class="language-typescript">import { APIGatewayProxyEvent } from "aws-lambda";\nimport { PrismaClient } from "@prisma/client";\n\nconst prisma = new PrismaClient();\n\nexport const connect = async (event: APIGatewayProxyEvent) =&gt; {\n  const connectionId = event.requestContext.connectionId;\n  await prisma.wSConnection.create({\n    data: {\n      connectionID: connectionId,\n    },\n  });\n  return { statusCode: 200, body: JSON.stringify({ connectionId }) };\n};</code></pre><hr><p>All that is accomplished here is the creation of an entry in a database and returns the connectionID (was simply used for debugging), AWS holds open the connection by default, and the reason for the entry is for propagation of messages to specific channels which we will get to later.</p><p>Here is the client side code for the interaction:</p><p></p><hr><pre><code class="language-typescript">useEffect(() =&gt; {\n  if (!socketRef.current) {\n    const newSocket = new WebSocket(process.env.NEXT_PUBLIC_WEBSOCKET as string);\n    socketRef.current = newSocket;\n    setSocket(newSocket);\n  }\n  if (socket) {\n    socket.onopen = () =&gt; {\n      console.log("Socket opened");\n    };\n    socket.onclose = () =&gt; {\n      if (socket?.readyState !== WebSocket.OPEN) {\n        socketRef.current = null;\n        setSocket(null);\n      }\n    };\n\n    return () =&gt; {\n      socket?.close();\n    };\n  }\n}, [socket]);</code></pre><hr><p>Very simple and straightforward, it connects when the page loads (<a target="_blank" rel="noopener noreferrer nofollow" href="https://www.weavechat.net/app">see here</a>) and it manages reconnects if a disconnect happens.</p><p>So at this point we have a connection to the Weave WebSocket, and an entry of a connectionID in a database. The user is also not in a specific server or channel.</p><p>When the WebSocket state changes to connected - stored like so -</p><p><code>const [socket, setSocket] = useState&lt;WebSocket | null&gt;(null);</code></p><p>- this useEffect is fired to update the WebSocket with the users id (and potentially the server channel if the user is viewing one - this is used during reconnections )</p><hr><pre><code class="language-typescript">const socketUserUpdate = () =&gt; {\n  socket?.send(\n    JSON.stringify({\n      senderID: currentUser?.id,\n      updateType: "user",\n    })\n  );\n};\n\nuseEffect(() =&gt; {\n  if (socket &amp;&amp; socket.readyState === WebSocket.OPEN &amp;&amp; currentUser) {\n    if (selectedChannel) {\n      socketChannelUpdate();\n    } else {\n      socketUserUpdate();\n    }\n  }\n}, [socket, currentUser]);</code></pre><hr><p>Next, if the user clicks on a server channel, the following code is executed.</p><hr><pre><code class="language-typescript">const socketChannelUpdate = async () =&gt; {\n  socket?.send(\n    JSON.stringify({\n      senderID: currentUser?.id,\n      channelID: selectedChannel?.id,\n      updateType: "channel",\n    })\n  );\n};</code></pre><hr><p>And for the previous two functions this is how it is handled on the WebSocket side of things</p><hr><pre><code class="language-typescript">import { APIGatewayProxyEvent } from "aws-lambda";\nimport { PrismaClient } from "@prisma/client";\n\nconst prisma = new PrismaClient();\n\ntype payloadType = {\n  senderID: string;\n  channelID?: number;\n  updateType: string;\n  conversationID?: number;\n};\n\nexport async function handler(event: APIGatewayProxyEvent) {\n  let payload: payloadType = JSON.parse(event.body);\n  const updateType = payload.updateType;\n  const senderID = payload.senderID;\n  const connectionId = event.requestContext.connectionId;\n\n  switch (updateType) {\n    case "channel":\n      if (payload.conversationID) {\n        await prisma.wSConnection.update({\n          where: {\n            connectionID: connectionId,\n          },\n          data: {\n            conversationID: payload.conversationID,\n            userId: senderID,\n            channelID: null,\n          },\n        });\n      } else {\n        const channelID = payload.channelID;\n\n        await prisma.wSConnection.update({\n          where: {\n            connectionID: connectionId,\n          },\n          data: {\n            conversationID: null,\n            channelID: channelID,\n            userId: senderID,\n          },\n        });\n      }\n      break;\n    case "user":\n      await prisma.wSConnection.update({\n        where: {\n          connectionID: connectionId,\n        },\n        data: {\n          userId: senderID,\n        },\n      });\n  }\n  return { statusCode: 200, body: "Connection updated." };\n}</code></pre><hr><p>And thats all for the connections! ðŸŽ‰</p><p>Now the user is subscribed to a channel and any messages sent by other users in the same channel will be pushed to them!</p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/projects/Weave p.1/weaveHomePage.jpg','2023-07-23 21:18:28',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5OTAxNzk5MSwiZXhwIjoxNzAwMjI3NTkxfQ.UmPuhMO1-LB5oPG-rrd7ZZqsvJHP_EtCaofXZMdc7vs',13,NULL);
INSERT INTO Post VALUES(2,'Weave_pt.2','Websockets',replace('<h3>Part 2. Sending Messages</h3><p>The most straightforward and obvious use of a WebSocket used by Weave is to send and push messages, here is the code executed on the sender side.</p><pre><code class="language-typescript">const sendMessage = async (e: React.FormEvent) =&gt; {\n  e.preventDefault();\n  if (messageInputRef.current &amp;&amp; socket) {\n    const input = messageInputRef.current.value;\n    if (input.length &gt; 0) {\n      setIconClass("move-fade");\n      const data = {\n        message: input,\n        senderID: currentUser.id,\n        channelID: selectedChannel.id,\n        action: "message",\n      };\n      socket.send(JSON.stringify(data));\n      messageInputRef.current.value = "";\n      setTimeout(() =&gt; {\n        setIconClass("");\n      }, 500);\n    }\n  }\n};</code></pre><p>The important bit is</p><pre><code class="language-typescript">const data = {\n  message: input,\n  senderID: currentUser.id,\n  channelID: selectedChannel.id,\n  action: "message",\n};</code></pre><p>The way this is consumed by the WebSocket is as follows: <strong><em>keep in mind, this is not optimized it simply works</em></strong></p><pre><code class="language-typescript">if (payload.conversationID) {\n//first check for a conversationID, this indicates a Direct Message,\n//not what is specifically being covered in this article\n}else if (payload.channelID) {\n    const channelID = payload.channelID;\n    let comment: Comment;\n    if (!payload.reaction) {\n      //negative check for a reaction\n      comment = await prisma.comment.create({\n        data: {\n          message: message,\n          channelID: channelID,\n          userId: senderID,\n        },\n      });\n    } else {\n     //this is where reactions are handled, not going over it yet\n    }\n    //find other connections to the same channel\n    const connections = await prisma.wSConnection.findMany({\n      where: {\n        channelID: channelID,\n      },\n    });\n    //error check\n    if (connections.length &gt; 0 &amp;&amp; (comment || payload.reaction)) {\n      await Promise.all(\n        connections.map(async (connection) =&gt; {\n          try {\n            const output = {\n              ConnectionId: connection.connectionID,\n              Data: JSON.stringify(payload.reaction ? "refresh" : comment),\n            };\n            await client.postToConnection(output).promise();\n          } catch (e) {\n            if (e.statusCode === 410) {\n              // If a connection is no longer available, delete it from the database.\n              await prisma.wSConnection.delete({\n                where: { connectionID: connection.connectionID },\n              });\n            }\n          }\n        })\n      );\n    }\n  }\n</code></pre><p>await Promise.all(x) wraps the contents in an async await pattern so that all the contained code is executed before moving on. The code here being wrapped is the pushing of the comment to each other connection in the same channel.</p><p>That was the simplest implementation of using the WebSocket. As all that happens is:</p><ol><li><p>user 1 sends message</p></li><li><p>lambda WebSocket check for channel message or direct message</p></li><li><p>check if the message is a reaction or comment</p></li><li><p>create new comment entry using prisma</p></li><li><p>find all connections (includes user 1) written in database</p></li><li><p>map over each connection (user 1...n) and push each connection a message "refresh" string.</p></li></ol><p>The reason for not sending the actual message, was due to not knowing at the time how to handle (sending/parsing) all the data needed client side. Instead, once the message is received, a new request to the db is made to get the new message.</p><pre><code class="language-typescript">  useEffect(() =&gt; {\n    if (socket) {\n      socket.onmessage = async (event) =&gt; {\n        console.log(event.data);\n        if (event.data.message !== "Internal server error") {\n          getMessagesQuery.refetch();\n        }\n      };\n    }\n  }, [socket]);</code></pre><p>getMessagesQuery.refetch() is a <a target="_blank" rel="noopener noreferrer nofollow" href="https://trpc.io/">trpc</a> query function. I really enjoyed working with trpc, however I have not used it on another site since Weave as I''ve been working with Next13 (app dir) since and trpc (and other bits, NextAuth, prisma etc. used to make Weave) don''t play great with Next13 yet, but also some, prisma for instance, have other performance costs that I wanted to ditch.</p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/projects/Weave pt.2/Screenshot 2023-07-25 at 4.58.55â€¯PM.jpg','2023-07-25 21:11:15',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5OTAxNzk5MSwiZXhwIjoxNzAwMjI3NTkxfQ.UmPuhMO1-LB5oPG-rrd7ZZqsvJHP_EtCaofXZMdc7vs',10,NULL);
INSERT INTO Post VALUES(3,'Weave_pt.3','WebRTC + Websockets',replace('<h2>Part 3. Video Connections with WebRTC</h2><p>If you have yet to read the first two parts on Weave, I would recommend doing so as it will help to understand the WebSocket end of this. You can read <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/projects/Weave_pt.1">part one here</a> and <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/projects/Weave_pt.2">part two here.</a></p><p>For video and voice chats, Weave uses WebRTC in a <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.geeksforgeeks.org/types-of-network-topology/">Mesh Topology Configuration</a>. The reason for doing so is to keep latency as low as possible, the drawback is that as n grows (n being the number of connections/peers), the cost of the connections grows substantially (born in cpu usage on the client as WebRTC runs on client side).</p><h3>First an overview of setting up WebRTC</h3><p>For simplicity this will cover a simple 2-peer connection</p><ol><li><p>Get user''s media(audio/video)</p></li><li><p>User 1 sends offer to user 2 with local description (this contains the media capabilities/settings of User 1)</p></li><li><p>User 2 sets received local description as a remote description of User 1 (User 2 now understands User 1)</p></li><li><p>User 2 responds to User 1 with their local description</p></li><li><p>User 1 receives answer and sets remote description of User 2. (both users now understand each other)</p></li><li><p>User 1 and 2 gather potential ICE Servers and exchange them to find a match</p></li><li><p>Once a match is found the media streams are shared (or data if used as data stream, for the purposes of Weave it is media)</p></li></ol><h3>When the user joins a video channel</h3><p>The following useEffects trigger:</p><pre><code class="language-typescript">  useEffect(() =&gt; {\n    if (connectedWSQuery.data) {\n      setWebSocketsInChannel(connectedWSQuery.data);\n    }\n  }, [connectedWSQuery]);\n\n//if there are other users in the channel, fires again if/when the user joins\n  useEffect(() =&gt; {\n    if (webSocketsInChannel) {\n      const wsInCall = webSocketsInChannel.filter((connection) =&gt; connection.inCall);\n      const userInCallBoolean = wsInCall.some((connection) =&gt; connection.user.id === currentUser.id);\n      setUserJoined(userInCallBoolean);\n      setWebSocketsInCall(wsInCall);\n    }\n  }, [currentUser.id, webSocketsInChannel]);\n//we will be coming back to this one\n  useEffect(() =&gt; {\n    socketOnMessage();\n  }, [socket]);\n</code></pre><p>These useEffects let the user know who is in the video call (won''t give video/audio as the connections haven''t yet been made), and this will also be used if the user joins the call to set up the webRTC mesh topology.</p><p>Joining the call is when the more complicated things happen. Here is the function that is fired when the user clicks ''Join''.</p><pre><code class="language-typescript">  const joinCall = async () =&gt; {\n    try {\n      setJoinButtonLoadingState(true);\n      stream.current = await navigator.mediaDevices.getUserMedia(constraints);\n\n     //quickly updates db that the user is in the call, this is necessary as the user by default is in the channel but not in the call, otherwise if someone accidentally clicks the channel button they will be added into the call\n      await joinOrLeaveCallMutation.mutateAsync({\n        newState: true,\n        channelID: selectedChannel.id,\n      });\n     //update client side state\n      await connectedWSQuery.refetch();\n      //send a message to the WebSocket mentioned in previous Weave articles that is functioning here as the signaling server\n      socket?.send(\n        JSON.stringify({\n          action: "audio",\n          type: "join",\n          userID: currentUser.id,\n        })\n      );\n      //this is where the connections are created and the mesh is established\n      await Promise.all(\n        webSocketsInCall.map(async (socket) =&gt; {\n          await addPeer(socket.user.id, true);\n        })\n      );\n\n      setJoinButtonLoadingState(false);\n    } catch (err) {\n     //non handling of error :/\n      console.log(err);\n    }\n  };</code></pre><p>Before I mentioned the two users sending each-other messages. Their browsers don''t know how to do this a priori as the users don''t know where precisely to send a message. This is done through a signaling server. The signaling server is the WebSocket mentioned in Weave pt. 1 and 2. As such I will only be briefly going over the WebSocket of things. The socket send action we will skip over for now, looking at the Promise.all() the array containing users already connected and in the call (webSocketsInCall) is mapped over and addPeer is called. Referring back to the overview will really help understand each step here</p><pre><code class="language-typescript">  const addPeer = async (peerUserID: string, initiator: boolean) =&gt; {\n    const newPeerConnection = new RTCPeerConnection();\n    //add onicecandidate event listener, needed for step 6\n    newPeerConnection.onicecandidate = (event) =&gt; {\n      if (event.candidate &amp;&amp; socket) {\n        console.log("sending ice candidate");\n        socket.send(\n          JSON.stringify({\n            action: "audio",\n            type: "ice-candidate",\n            userID: currentUser.id,\n            targetUserID: peerUserID,\n            candidate: event.candidate,\n          })\n        );\n      }\n    };\n    //gets user media, needs to happen before offer/answer, otherwise ice candidates will not be collected, allows step 7\n    stream.current.getTracks().forEach((track) =&gt; {\n      console.log("adding local stream");\n      newPeerConnection.addTrack(track, stream.current);\n    });\n    //this is where the true input is used from back in the joinCall function\n    if (initiator) {\n      //step 2\n      const offer = await newPeerConnection.createOffer();\n      await newPeerConnection.setLocalDescription(offer);\n\n      console.log("Sending offer");\n      socket?.send(\n        JSON.stringify({\n          action: "audio",\n          type: "offer",\n          userID: currentUser.id,\n          targetUserID: peerUserID,\n          offer: newPeerConnection.localDescription,\n        })\n      );\n    }\n   // event listener that fires when remote stream is received, all of this sets up the state needed for the ui\n    newPeerConnection.ontrack = (event) =&gt; {\n      if (event.streams[0]) {\n        console.log("adding remote stream");\n        setPeerStreams((prevStreams) =&gt; {\n          const newStreams = new Map(prevStreams);\n          newStreams.set(peerUserID, event.streams[0] as MediaStream);\n          return newStreams;\n        });\n\n        const videoTrack = event.streams[0].getVideoTracks()[0];\n        const videoTrackEnabled = videoTrack?.enabled || false;\n        setVideoTrackStates((prevVideoTrackStates) =&gt; {\n          const newVideoTrackStates = new Map(prevVideoTrackStates);\n          newVideoTrackStates.set(peerUserID, videoTrackEnabled);\n          return newVideoTrackStates;\n        });\n      }\n    };\n    //debug to help identify when connection is established or fails\n    newPeerConnection.oniceconnectionstatechange = async () =&gt; {\n      console.log(`ICE connection state with ${peerUserID} changed to: ${newPeerConnection.iceConnectionState}`);\n    };\n\n    peerConnections.current?.set(peerUserID, newPeerConnection);\n    return newPeerConnection;\n  };</code></pre><p>You may notice that all of this only really pertains to user 1 in the overview. There were 3 useEffects at the top with the 3rd going unexplained. Here is the socketOnMessage function.</p><pre><code>//this wraps one event listener, the reason for not just writing the event listener is for dropped socket connections and reconnects\n  const socketOnMessage = () =&gt; {\n    if (socket) {\n      socket.onmessage = async (event) =&gt; {\n        const data = JSON.parse(event.data) as message | null;\n        if (data &amp;&amp; data.userID &amp;&amp; data.type) {\n          const senderID = data.userID;\n          const sendingConnection = peerConnections.current?.get(senderID);\n\n          switch (data.type) {\n            case "join":\n              //keeps each user up to date on who is in the call, even if they themselves are not in the call. Needed for joining!\n              //image the case where someone joins the channel, and 3 people are in the call. A fourth joins the call, but that person\n              //would be unknown and wouldn''t receive the joinCall cascade\n              await connectedWSQuery.refetch();\n              break;\n\n            case "offer":\n              //step 3 in overview\n              console.log("receive offer");\n              await addPeer(senderID, false);\n              const newPeer = peerConnections.current.get(senderID);\n              if (newPeer &amp;&amp; data.offer) {\n                await newPeer.setRemoteDescription(new RTCSessionDescription(data.offer));\n                const answer = await newPeer.createAnswer();\n                await newPeer.setLocalDescription(answer);\n                console.log("Sending answer");\n                //step 4\n                socket.send(\n                  JSON.stringify({\n                    action: "audio",\n                    type: "answer",\n                    userID: currentUser.id,\n                    targetUserID: senderID,\n                    answer: newPeer.localDescription,\n                  })\n                );\n              } else {\n                console.error("Peer Creation Failed!");\n                console.log(peerConnections.current);\n              }\n\n              break;\n            case "answer":\n              //step 5\n              console.log("receive answer");\n              if (sendingConnection &amp;&amp; data.answer) {\n                await sendingConnection.setRemoteDescription(new RTCSessionDescription(data.answer));\n              } else {\n                console.error("Peer Creation Failed!");\n                console.log(peerConnections.current);\n              }\n              break;\n\n            case "ice-candidate":\n              //step 6\n              console.log("received ice candidate");\n              if (sendingConnection) {\n                if (sendingConnection.remoteDescription &amp;&amp; data.candidate) {\n                  await sendingConnection.addIceCandidate(new RTCIceCandidate(data.candidate));\n                } else {\n                  console.error("Remote description is not set yet. Ignoring ICE candidate.");\n                }\n              }\n              break;\n\n            case "leave":\n              removePeer(senderID);\n              await connectedWSQuery.refetch();\n              break;\n          }\n        }\n      };\n    }\n  };</code></pre><p>Thankfully all of the RTCPeerConnection class functions are clearly named, and if you know the cascade of what needs to happen it is relatively easy to follow. The is the entirety signaling server logic, the way it is routed to is in the action in the send.</p><pre><code class="language-typescript">                socket.send(\n                  JSON.stringify({\n       here -----&gt;  action: "audio",\n                    type: "answer",\n                    userID: currentUser.id,\n                    targetUserID: senderID,\n                    answer: newPeer.localDescription,\n                  })\n                );</code></pre><pre><code class="language-typescript">import { APIGatewayProxyEvent } from "aws-lambda";\nimport { PrismaClient, WSConnection } from "@prisma/client";\nimport * as AWS from "aws-sdk";\n\nconst prisma = new PrismaClient();\n\ntype payloadType = {\n  channelID: number;\n  type: string;\n  userID?: string;\n  targetUserID?: string;\n  candidate?: any;\n  offer?: any;\n  answer?: any;\n};\n\nexport async function handler(event: APIGatewayProxyEvent) {\n  let payload: payloadType = JSON.parse(event.body);\n  const senderConnection = event.requestContext.connectionId;\n  const requestType = payload.type;\n  //get connection id from database\n  const sender_connection = await prisma.wSConnection.findFirst({\n    where: {\n      connectionID: senderConnection,\n    },\n  });\n  let target_connection: WSConnection | null;\n  try {\n    if (payload.targetUserID) {\n      target_connection = await prisma.wSConnection.findFirst({\n        where: {\n          userId: payload.targetUserID,\n        },\n      });\n    }\n  } catch (err) {}\n  const client = new AWS.ApiGatewayManagementApi({\n    endpoint: `https://${event.requestContext.domainName}/${event.requestContext.stage}`,\n  });\n\n  switch (requestType) {\n    case "ice-candidate":\n      const output = {\n        ConnectionId: target_connection.connectionID,\n        Data: JSON.stringify({\n          type: "ice-candidate",\n          userID: payload.userID,\n          candidate: payload.candidate,\n        }),\n      };\n      await client.postToConnection(output).promise();\n\n      return { statusCode: 200, body: "ice forwarded" };\n    case "offer":\n      const offerOutput = {\n        ConnectionId: target_connection.connectionID,\n        Data: JSON.stringify({\n          type: "offer",\n          userID: payload.userID,\n          offer: payload.offer,\n        }),\n      };\n      await client.postToConnection(offerOutput).promise();\n      return { statusCode: 200, body: "offer forwarded" };\n    case "answer":\n      const answerOutput = {\n        ConnectionId: target_connection.connectionID,\n        Data: JSON.stringify({\n          type: "answer",\n          userID: payload.userID,\n          answer: payload.answer,\n        }),\n      };\n      await client.postToConnection(answerOutput).promise();\n      return { statusCode: 200, body: "answer forwarded" };\n    case "join":\n      const inChannel = await prisma.wSConnection.findMany({\n        where: {\n          channelID: sender_connection.channelID,\n        },\n      });\n      //only place where the the target cannot be know on the senders side\n      await Promise.all(\n        inChannel\n          .filter((connection) =&gt; connection.connectionID !== senderConnection)\n          .map(async (connection) =&gt; {\n            const output = {\n              ConnectionId: connection.connectionID,\n              Data: JSON.stringify({\n                userID: payload.userID,\n                type: requestType,\n              }),\n            };\n            await client.postToConnection(output).promise();\n          })\n      );\n      return { statusCode: 200, body: "message forwarded" };\n    case "leave":\n      const connections = await prisma.wSConnection.findMany({\n        where: {\n          channelID: sender_connection.channelID,\n        },\n      });\n      await Promise.all(\n        connections\n          .filter((connection) =&gt; connection.connectionID !== senderConnection)\n          .map(async (connection) =&gt; {\n            const output = {\n              ConnectionId: connection.connectionID,\n              Data: JSON.stringify({\n                userID: payload.userID,\n                type: requestType,\n              }),\n            };\n            await client.postToConnection(output).promise();\n          })\n      );\n      return { statusCode: 200, body: "message forwarded" };\n    default:\n      console.error("Unknown message type:", payload.type);\n  }\n}\n</code></pre><p>And that''s all the logic for getting connected ðŸ˜…</p><p>I like switch statements aesthetically. Wish they were better, like rust''s match ðŸ¤·</p><p>Anyway, I haven''t gone through any of the ui for anything in Weave which I will cover next!</p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/projects/Weave pt.3/WeaveVideoChannel.jpg','2023-07-27 22:26:15',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5OTAxODMyOSwiZXhwIjoxNzAwMjI3OTI5fQ.sRApbwnsVM8l833puuSaWWJLOngp0a_zHY_TvYu1EI0',11,NULL);
INSERT INTO Post VALUES(4,'Creating_an_OCaml_Library','First library for any language!',replace('<h3>So I''ve never made a library before...</h3><p>So I started very simple, and focused on solving a rough edge while learning OCaml. Learning a new language I often am running through <a target="_blank" rel="noopener noreferrer nofollow" href="https://adventofcode.com/">Advent of Code</a>, and while doing so I need to print various data structures to the terminal and was frustrated by how difficult it was in OCaml when printing anything more complex than a primitive, using the <a target="_blank" rel="noopener noreferrer nofollow" href="https://v2.ocaml.org/api/Format.html">Format Module</a>. This is pretty rough if you just want something quick and dirty. It was doable for Advent of Code, but then I then started <a target="_blank" rel="noopener noreferrer nofollow" href="https://v2.ocaml.org/learn/tutorials/99problems.html">99 problems</a> and that was not so great as I was running through problems very quickly and just needed an output.</p><p>Doing the following:</p><pre><code class="language-ocaml">  let int_list_to_str ?(prefix = "") list =\n    let s = prefix ^ String.concat "; " (List.map string_of_int list) in\n    Printf.sprintf "[%s]" s\n  in\n</code></pre><p>Just to print out int list was rough, so I created a library real quick.</p><p>It was actually not that bad. The programming side likely took less than half the time, with the majority of the time figuring out an Open SSL install error, setting up SSH keys and documenting the code (thankfully that wasn''t too bad with the help of ChatGPT). Anyway, the more complicated data printing is probably more useful, so here is the code for printing an Hash table with string keys and float list as values</p><pre><code class="language-ocaml">let hashtable_string_float_list ?(prefix = "") ?(precision = 2) ht =\n  let float_list_to_str ?(prefix = "") ?(precision = 2) list =\n    let float_to_str f = Printf.sprintf "%.*f" precision f in\n    let s = prefix ^ String.concat "; " (List.map float_to_str list) in\n    Printf.sprintf "[%s]" s\n  in\n  print_string (prefix ^ "{");\n  Hashtbl.iter\n    (fun k v -&gt;\n      let float_list = float_list_to_str ~precision v in\n      Printf.printf "(%s, %s); " k float_list)\n    ht;\n  print_endline "}"</code></pre><p>And this code would be called like this:</p><pre><code class="language-ocaml">Quick_print.hashtable_string_float_list ~prefix:"MyHashTable: " ~precision:2 hash_table in\n(* output = MyHashTable: {(excuse me, [4.99; 5.88; 6.77]); (sir, [7.10; 8.01; 9.00]); (this is a wendy''s, [1.12; 2.12; 3.23]); } *)</code></pre><p>Each function is named by its type left -&gt; right. They all have an optional parameter (prefix) to print inline before the data structure. Floats also have an optional precision parameter to specify the number of digits trailing the decimal, which defaults to 2.</p><p>It''s simple, trades customization for ease of use, so mainly useful for testing and learning purposes. I mainly made this library for myself, for future debugging and learning sessions, but hopefully someone somewhere gets some use out of it! The library can be found <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/mikefreno/quick_print">here.</a></p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/projects/Creating an OCaml Library/updated_screenshot.jpg','2023-07-27 22:26:15',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5OTAxODMyOSwiZXhwIjoxNzAwMjI3OTI5fQ.sRApbwnsVM8l833puuSaWWJLOngp0a_zHY_TvYu1EI0',17,NULL);
INSERT INTO Post VALUES(5,'Weave_Addendum','Looking over design decisions','<h2>Looking at what was done wrong.</h2><p>Weave was made with the <a target="_blank" rel="noopener noreferrer nofollow" href="https://create.t3.gg/">t3 stack</a> (typescript, next.js, prisma, tRPC, tailwind, NextAuth) and at the time it was supremely helpful getting started with nextjs and a project that had a large scope and with much larger ambitions than anything I had done before.</p><h3>Problems with t3</h3><ol><li><p>The main issue I had with t3 was the use of prisma (while this is optional, I had no reason to assume it to be an issue). I decided that it would work well as I had never written raw SQL, previously I had only used python based backends, flask and Django and hadnâ€™t need to write SQL. This was a massive mistake as prisma works very poorly in a serverless environment, itâ€™s got a very slow cold start, which is bad enough but it gets worse. Prisma doesnâ€™t do actual sql joins. I never would have guessed that would be the case but it was a very good learning experience for future as I will never not use such an important piece of a stack, how interactions with my database so flippantly. Plus just writing SQL (which Iâ€™ve done for this website), really isnâ€™t that hard anyway.</p></li><li><p>NextAuth is my only other significant regret and not for any kind of reason like prisma. NextAuth does what it advertises and does it quite well. It makes authentication very easy and secure so no regrets on that front. My only regret is that when trying to hook in desktop or mobile, it becomes a nightmare. I just couldnâ€™t get it to work with leptos(rust by the way) and expo wasnâ€™t looking great either before I gave up on it as it was simply taking up too much time and the mobile/ desktop was just going to be for a learning experience anyway. It did however look after some digging that it wouldnâ€™t look too painstaking with electron but I really didnâ€™t want to use electron as I hate using every electron app on my computer.</p></li></ol><h3>What was good about t3</h3><ol><li><p>Without reservation my favorite thing in t3 was hilariously one of the smallest things, itâ€™s environment variables solution. <a target="_blank" rel="noopener noreferrer nofollow" href="https://env.t3.gg/">https://env.t3.gg/</a> Itâ€™s great. It uses zod under the hood to make sure that you have envs you expect in place and you can also put in restrictions for length etc to make sure it is in the form you expect. Small but super handy and easy to use.</p></li><li><p>It took some time to get used to and I havenâ€™t used it again because as of writing this it doesnâ€™t play well with next13 yet, but I really enjoyed using tRPC. Its main drawback is being a little weird to learn and quite a lot of boilerplate (much of which t3 takes care of for you), but is super user as it essentially upgrades your apis to superJSON and keeps your frontend in the know at the same time so no need for type casting .json() from any, all your potential api returns are known on the frontend. Super helpful and will most likely use again.</p></li><li><p>Hesitant to include this because I used it before and will always and forever use it in the future: tailwind. Itâ€™s great, not question about it, if you write css and havenâ€™t used it, why? Itâ€™s just a bunch of utility classes that are standard stuff, makes maintaining frontend code and creating it super easy. It also cleans up what you donâ€™t use so you donâ€™t ship unnecessary css to a users device. It would be number 1 best thing if it wasnâ€™t so popular already and a basic guaranteed use before hand.</p></li></ol><h3>Other design decisions</h3><ol><li><p>My other main regret was not understanding how next actually worked. I had used react once before making weave and it was a very simple SPA and I was thinking in the same model when creating Weave, not understanding how &lt;Link&gt; tags in next work to create what is essentially SPA levels of smooth navigation, but with none of the down sides of a SPA. <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.weavechat.net/app">Weave''s /app page</a> should have been made with every different server being a different url, but it was made effectively as a SPA and that was a massive mistake.</p></li><li><p>Next13 with its app dir was released right around when I was starting Weave and it seemed to confusing to use (Weave uses next 12). Having now used it to make 3 websites now(this one included) I deeply regret not spending the time to learn it right from the start.</p></li></ol><h3>Wrapping up...</h3><p>Making Weave was a massive learning experience and while I wish I had chosen some different choices at the start it was still a lot of fun to create and made me a much better developer for having created it :).</p>','https://frenomeimages.s3.amazonaws.com/blog/Weave Addendum/WeavePrismaCode.jpg','2023-07-31 01:59:00',1,'blog','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5OTAxODMyOSwiZXhwIjoxNzAwMjI3OTI5fQ.sRApbwnsVM8l833puuSaWWJLOngp0a_zHY_TvYu1EI0',18,NULL);
INSERT INTO Post VALUES(6,'OCaml_my_Camel','First steps in FP',replace('<h2>Preface</h2><p>My programming journey is as follows:</p><ol><li><p>Little bit of Java in college (went for genetics- did one class with java)</p></li><li><p>Started learning python in late 2021</p></li><li><p>Had good understanding of python by mid 2022, started web dev - html, css, JavaScript</p></li><li><p>Started with React and node in fall 2022, side focus on relearning Java</p></li><li><p>Started typescript in early 2023 along with next.js</p></li><li><p>Started learning rust and go and c# shortly after, not a significant focus</p></li><li><p>Good understand of typescript around now :)</p></li><li><p>Started focusing on rust summer 2023</p></li><li><p>Now starting ocaml after some familiarity gained in rust</p></li></ol><p>To give a quick rank ordering of my familiarity with each:</p><p>TS/JS &gt; Rust &gt; Python(although slightly rusty with it) &gt; c# &gt; Java &gt; go</p><p>This is just to say that while my programming career is brief I have played around with different languages enough to know things I do and donâ€™t like</p><h3>Things I like</h3><ul><li><p>Pattern matching</p></li><li><p>Errors as values</p></li><li><p>Good build tools / ecosystems</p></li><li><p>Static typing</p></li><li><p>Inferred Types</p></li></ul><h3>Things I hate</h3><ul><li><p>Java</p></li><li><p>Paradigms as dogmas</p></li><li><p>Thrown exceptions</p></li><li><p>Dynamic typing systems</p></li><li><p>Inferred Type <em>definitions</em></p></li><li><p><em>if err !=nil {return err}</em></p></li></ul><p>If you have knowledge of the languages I have mentioned you can probably see the progenitors of these opinions.<br>Quickly, I hate the error handling of javascript with a passion, and go''s while bad I don''t hate, and it''s kind of a meme. Dynamic typing a la python is gross and it''s the main reason I don''t have an interest with Elixir even though it is somewhat hot right now as far as functional programming is concerned. I hate forcing of a paradigm, everything in java/c# being a class or Haskell everything being immutable. It''s bad, and leads to significant performance loss or overly convoluted code. OOP dogma leads to over abstraction thereby needless confusion and FP dogma leads to slow code.</p><p>Paradigms should be an encouraged style, but they should be bendable, OCaml allows this with mutability with ref (creates a simple record of a given type) and more complex records.</p><p>As for the good things, good pattern matching I first encountered with rust and fell in love immediately, consider this code</p><pre><code class="language-rust">fn get_priority(c: char) -&gt; Option&lt;i32&gt; {\n    //gets an integer from a given character (value from problem prompt)\n    match c {\n        ''a''..=''z'' =&gt; Some((c as i32) - (''a'' as i32) + 1),\n        ''A''..=''Z'' =&gt; Some((c as i32) - (''A'' as i32) + 27),\n        _ =&gt; None,\n    }\n}</code></pre><p>So nice. And the same logic is extremely similar in OCaml</p><pre><code class="language-ocaml">let get_priority c =\n  match c with\n  | ''a''..''z'' -&gt; Char.code c - Char.code ''a'' + 1\n  | ''A''..''Z'' -&gt; Char.code c - Char.code ''A'' + 27\n  | _ -&gt; failwith "invalid character"</code></pre><p>So when I ended up writing this OCaml code I knew I wanted to get really <em>really into this thing...ðŸ˜œ</em></p><pre><code class="language-ocaml">let update_top_three max_3 x =\n  match max_3 with\n  | [| a; b; _ |] when x &gt; a -&gt; [| x; a; b |]\n  | [| a; b; _ |] when x &lt;= a &amp;&amp; x &gt; b -&gt; [| a; x; b |]\n  | [| a; b; c |] when x &lt;= b &amp;&amp; x &gt; c -&gt; [| a; b; x |]\n  | max_3 -&gt; max_3\n</code></pre><p>So that''s really awesome. I''m currently running through <a target="_blank" rel="noopener noreferrer nofollow" href="https://adventofcode.com/">Advent of Code</a> (my preferred way of learning a new language) and so far, while struggling with the syntax and trying to shift off a more imperative style, I have been really enjoying the experience. Also, dune so far (the build tool for OCaml) has been surprisingly solid, and I love the name. It''s cute.</p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/blog/Learning Ocaml/camel-1.1000x800se.jpg','2023-08-14 02:30:48',1,'blog','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5ODc3MDEzMiwiZXhwIjoxNjk4ODEzMzMyfQ.KqpZsxeH05ELEGhzqkp7JxZcBWfPGzwQM1dh5vQgOkY',12,NULL);
INSERT INTO Post VALUES(7,'VS_Code_->_Nvim','Making the switch',replace('<h3>Fully moving to vim.</h3><p>I have been trying to move towards vim for a little while, using vim bindings in VS Code, however I wasnâ€™t learning as fast as I wanted. I often ending up not using them unless I could remind myself to do so as at start it was slower than using vs code/macos keyboard shortcuts.</p><p>So to solve the slow learning curve I have decided to make the dive and go fully into Vim. My setup is as follows:</p><ol><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://neovim.io/">Neovim</a></p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/alacritty/alacritty">Alacritty</a> I am using this to have consistency across platforms, as I use macOS as my main machine (for now ðŸ‘€) and windows occasionally and trying out Linux (Debian &amp; Ubuntu) and would like to keep everything as consistent as possible, mine is <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/mikefreno/alacritty-config">here</a>. Additionally I have the following script run as a cron job every 5 minutes to switch alacritty''s color theme at a specific time</p></li></ol><pre><code class="language-bash">#based on system time\nFILE=~/.config/alacritty/alacritty.yml\nMOCHA="catppuccin-mocha"\nLATTE="catppuccin-latte"\n\nHOUR=$(date +%H)\n\nif (( 10#$HOUR &gt;= 7 &amp;&amp; 10#$HOUR &lt; 17 )); then\n    sed -i '''' "s|$MOCHA|$LATTE|g" $FILE\nelse\n    sed -i '''' "s|$LATTE|$MOCHA|g" $FILE\nfi</code></pre><p><em>Edit:</em> I changed the theme to depend on system theme instead of system time, additionally I added a transparency to only the dark mode/mocha, as it made the light mode/mocha difficult to read.</p><pre><code class="language-bash">#based on system theme\nFILE=~/.config/alacritty/alacritty.yml\nMOCHA="catppuccin-mocha"\nLATTE="catppuccin-latte"\n\nIS_DARK_MODE=$(osascript -e ''tell application "System Events" to tell appearance preferences to return dark mode'')\n\nCURRENT_THEME=$(grep -o "$LATTE\|$MOCHA" "$FILE")\n\nif [[ $IS_DARK_MODE == "true" ]]; then\n    # If current theme is not MOCHA, then switch to MOCHA\n    if [ "$CURRENT_THEME" != "$MOCHA" ]; then\n        sed -i '''' "s|$LATTE|$MOCHA|g" $FILE\n        sed -i '''' "s|opacity: 1.0|opacity: 0.95|g" $FILE\n    fi\nelse\n    # If current theme is not LATTE, then switch to LATTE\n    if [ "$CURRENT_THEME" != "$LATTE" ]; then\n        sed -i '''' "s|$MOCHA|$LATTE|g" $FILE\n        sed -i '''' "s|opacity: 0.95|opacity: 1.0|g" $FILE\n    fi\nfi</code></pre><ol start="3"><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/tmux/tmux/wiki">Tmux</a> - find my config <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/mikefreno/tmux-conf/blob/master/tmux.conf">here</a></p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/nvim-lua/kickstart.nvim">Kickstart.nvim</a> (to get me started)</p></li><li><p>My current <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/mikefreno/neovim-init/blob/master/init.lua">init.lua</a></p></li></ol><p>I spent about a day and a half to get to this point, including research, trying out different terminal emulators, tried nvchad. Moving forward Iâ€™m going to be running with this setup for at least a few months. I donâ€™t want to get trapped into constantly refining my setup. It works, looks nice and Iâ€™m excited to get moving blazingly fastðŸ”¥</p><p>And here is what it looks like:</p><p>light mode:</p><img src="https://frenomeimages.s3.amazonaws.com/blog/VS_Code_-%3E_Nvim/light-mode.jpg"><p>dark mode:</p><img src="https://frenomeimages.s3.amazonaws.com/blog/VS_Code_-%3E_Nvim/dark-mode.jpg">','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/blog/VSCode to Nvim/Vimlogo.svg.png','2023-09-12 20:21:54',1,'blog','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5ODc4MDY4NCwiZXhwIjoxNjk5OTkwMjg0fQ.uCmEBwa5Xkgzc0-QNn-ZO7yia9YFTixsLJ0r-RiyUb8',148,NULL);
INSERT INTO Post VALUES(8,'Bitcoin_Starter','A Directory of Sorts','<h3>The Goal of this article is to be a politically neutral starting place to learn about Bitcoin.</h3><p>That doesnâ€™t mean that it is neutral on bitcoin- it isnâ€™t at all. But rather it will simply have resources and arguments that may appeal to those who see themselves on the left, which are irrelevant to those on the right and the reverse. This is due to bitcoins relative monoculture online. One that I think is unhelpful, and potentially counterproductive . I believe bitcoins community of what I would call right-leaning crypto-libertarianism (crypto here referring to secrecy and privacy, not to cryptocurrency) to be borne from important root causes that may be waning. <strong>Bitcoin is for everyone. </strong>However, for the majority of its existence bitcoin has had significant detractors, which has cultivated a very defensive insular bitcoin community. But education and resources have reached a point where nearly any argument against bitcoin can be countered from numerous directions. Those varying arguments will be the focal point of the various books/articles/podcasts etc listed in the following sections, headed with the argument. Some will have sub-arguments that will be listed with a smaller subheading.</p><h2>Bitcoin is bad for the environment</h2><h3>Bitcoin uses too much energy</h3>','https://frenomeimages.s3.amazonaws.com/blog/Bitcoin Starter/Bitcoin.svg.png','2023-09-12 20:21:54',0,'blog','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTY5ODc4MDY4NCwiZXhwIjoxNjk5OTkwMjg0fQ.uCmEBwa5Xkgzc0-QNn-ZO7yia9YFTixsLJ0r-RiyUb8',241,NULL);
INSERT INTO Post VALUES(9,'Smart_Mirror_Build','','<h3>Last year I made a Smart Mirror</h3><p>What''s needed/what I used:</p><p>Atoms</p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://a.co/d/a42qQyO">Sceptre 20" Ultra Thin LED Monitor</a></p></li><li><p>18 x 24in 2-way mirror</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/">Raspberry Pi 4 Model B</a></p></li><li><p>Micro SD - 64gb is more than enough</p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://a.co/d/34GbFJL">Google AIY Voice Kit</a> (optional for voice commands)</p></li><li><p>Wood, screws</p></li><li><p>Wood Stain</p></li></ul><p>Bits</p><ul><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.raspbian.org">Raspbian</a></p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/MichMich/MagicMirror">MagicMirrorÂ²</a></p></li><li><p><a target="_blank" rel="noopener noreferrer nofollow" href="https://etcher.balena.io">Etcher</a> (or something similar) </p></li></ul><p>Below is a video going over a similar build to mine</p><div class="iframe-wrapper"><iframe src="https://www.youtube.com/embed/aa3VVZA0e5Y?si=cGjmSnTf87RDnJ3D" frameborder="0" allowfullscreen="true"></iframe></div><p>90% of the time is the physical assembly. From the stain to the cuts, to the screws, it takes quite a lot of time. The software setup is easy, especially if you are used to software dev tools(I say this looking back, at the time I had no experience with software dev, and it wasn''t hard to get it going). MagicMirror''s <a target="_blank" rel="noopener noreferrer nofollow" href="https://docs.magicmirror.builders/getting-started/installation.html">docs</a> are very good for newbies to follow, as I was at time of creation.</p><p>It''s a fun project, I use it everyday. The end product is quite visually striking and I get comments of confusion and excitement regarding it all the time by visitors to my apartment.</p>','https://frenomeimages.s3.amazonaws.com/project/Smart_Mirror_Build/1000000153.jpeg','2023-10-31 23:01:54',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTcwMzg3MTAwNSwiZXhwIjoxNzA1MDgwNjA1fQ.DM8N9Yk1kqY2yUclYBVUnqMBJZLQmZqumOnsNpBGkQ0',87,NULL);
INSERT INTO Post VALUES(10,'Serverless_is_kinda_booty...','(and go is great)',replace('<h3>So I have been trying out different languages the last few months.</h3><p>Go, rust and OCaml. I had gotten tired of Typescript and its many weirdnesses, and for a few months I really focused on learning those three aforementioned language, and mostly enjoying the experience immensely(at least with Go and OCaml). So after a little while of doing that I revisited this website and refine a few things here and there. I wanted the comment section to use a WebSocket for real time updates. It was only the second time I had done a WebSocket (my first experience is covered in three parts <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/projects/Weave_pt.1">part 1</a>, <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/projects/Weave_pt.2">part 2</a>, and <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/projects/Weave_pt.3">part 3</a>) and as the rest of this site is done with Typescript I figured I would continue on with that and do the WebSocket with ts as I had done the first time.</p><h3>I quickly decided to scrape that.</h3><p>Maybe it was due to experiencing a much better time with OCaml and Go, but I had a very short patience with trying to make the WebSocket. I was running into both deployment issues and run of the mill development issues, but the lack of ability to actually see into the problem was really killing me, trying to even find where errors are being logged is annoying when dealing with serverless. And even when I found them, the time delay between trying to fix the problem and actually seeing if the problem was fixed was painfully long.</p><p>Eventually, I got it working. And the experience was dog water. The function execution time was anywhere from 200ms - 2.5seconds on a cold start. (For instance - <code>REPORT RequestId: b2c5ce4f-a334-457e-985c-7bbf91d172a8 Duration: 322.21 ms Billed Duration: 323 ms Memory Size: 1024 MB Max Memory Used: 132 MB Init Duration: 1701.55 ms</code> - taken from CloudWatch) Even when broadcasting to even small numbers of clients without a cold start, the round trip response was often over an entire second or 2. I was doing a whole bunch of work arounds for the sending user to see a response faster than waiting for the WebSocket response. Overall it was a terrible experience.</p><h3>So I decided to scrape it.</h3><p>I decided to use <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/gorilla/websocket">gorilla</a> for the WebSocket library. It was very easy to understand, and the documentation was great. The only rough edge is my comparative skill deficiency with Go vs JS/TS. And learning a new thing is never a bad thing.</p><p>It is by no means well done, but it works, and works so much better than the previous implementation that its kind of embarassing. The go code is quite bad, but it works something like 2 orders of magnitude faster and more importantly than that, the working are actually easily visible! Also, all it needs to build and deploy is a simple dockerfile. A massive improvement over the serverless framework mess.</p><p>Here is the entire go code, by all means critique the hell out of it, would love to know where improvements can be made</p><pre><code class="language-go">package main\n\nimport (\n	"database/sql"\n	"encoding/json"\n	"fmt"\n	_ "github.com/go-sql-driver/mysql"\n	"github.com/google/uuid"\n	"github.com/gorilla/websocket"\n	"github.com/joho/godotenv"\n	"log"\n	"net/http"\n	"os"\n	"strings"\n	"sync"\n)\n\ntype Data struct {\n	Action          string  `json:"action"`\n	DeleteType      *string `json:"deleteType"`\n	PostType        string  `json:"postType"`\n	PostID          *int    `json:"postID"`\n	InvokerID       string  `json:"invokerID"`\n	CommentBody     *string `json:"commentBody"`\n	ParentCommentID *int    `json:"parentCommentID"`\n	CommentID       *int    `json:"commentID"`\n	Reaction        *string `json:"reactionType"`\n}\n\ntype Client struct {\n	ID          string\n	Conn        *websocket.Conn\n	ChannelID   *int\n	ChannelType *string\n}\n\nvar clients = make(map[string]*Client)\nvar lock = sync.RWMutex{}\n\nvar upgrader = websocket.Upgrader{\n	ReadBufferSize:  1024,\n	WriteBufferSize: 1024,\n}\n\nvar db *sql.DB\n\n// for debugging\nfunc PrintClients(clients []*Client) {\n	lock.RLock()\n	defer lock.RUnlock()\n	for _, client := range clients {\n		log.Println("ID:", &amp;client.ID)\n		log.Println("Connection:", &amp;client.Conn)\n		log.Println("ChannelID:", &amp;client.ChannelID)\n		log.Println("ChannelType:", &amp;client.ChannelType)\n		log.Println()\n	}\n}\nfunc PrintClientsMap() {\n	lock.RLock()\n	defer lock.RUnlock()\n	for key, client := range clients {\n		log.Println("Client Key:", key)\n		log.Println("ID:", client.ID)\n		log.Println("Connection:", &amp;client.Conn)\n		log.Println("ChannelID:", client.ChannelID)\n		log.Println("ChannelType:", client.ChannelType)\n		log.Println()\n	}\n}\n\nfunc createDBConnection() *sql.DB {\n	err := godotenv.Load()\n	if err != nil {\n		log.Printf("Error loading .env file")\n	}\n\n	db, err := sql.Open("mysql", os.Getenv("DSN"))\n	if err != nil {\n		log.Fatalf("failed to connect: %v", err)\n	}\n\n	if err := db.Ping(); err != nil {\n		log.Fatalf("failed to ping: %v", err)\n	}\n	return db\n}\n\nfunc getAllConnectionsInChannel(post_id int, post_type string) []*Client {\n	lock.RLock()\n	defer lock.RUnlock()\n	var clientsInChannel []*Client\n	for _, client := range clients {\n		if client.ChannelID != nil &amp;&amp; client.ChannelType != nil &amp;&amp;\n			*client.ChannelID == post_id &amp;&amp; *client.ChannelType == post_type {\n			clientsInChannel = append(clientsInChannel, client)\n		}\n	}\n	return clientsInChannel\n}\n\nfunc broadcast(message []byte, clients []*Client) {\n	for _, client := range clients {\n		err := client.Conn.WriteMessage(websocket.TextMessage, message)\n		if err != nil {\n			fmt.Println("write error:", err)\n			client.Conn.Close()\n		}\n	}\n}\n\nfunc channelUpdate(data Data, client *Client) {\n	lock.Lock()\n	defer lock.Unlock()\n	client, exists := clients[client.ID]\n	if exists {\n		client.ChannelType = &amp;data.PostType\n		client.ChannelID = data.PostID\n	}\n}\n\nfunc commentCreation(data Data) {\n	noParentSafe := -1\n	if data.ParentCommentID != nil {\n		noParentSafe = *data.ParentCommentID\n	}\n	query := fmt.Sprintf(`INSERT INTO Comment (body, %s, parent_comment_id, commenter_id) VALUES (?, ?, ?, ?)`, (data.PostType + "_id"))\n	params := []interface{}{\n		data.CommentBody,\n		data.PostID,\n		data.ParentCommentID,\n		data.InvokerID,\n	}\n	res, err := db.Exec(query, params...)\n	if err != nil {\n		log.Printf("Failed to execute query: %v", err)\n		return\n	}\n	commentID, err := res.LastInsertId()\n	if err != nil {\n		log.Printf("Failed to retrieve ID: %v", err)\n		return\n	}\n	broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n	jsonMsg, err := json.Marshal(&amp;struct {\n		Action        string `json:"action"`\n		CommentID     int64  `json:"commentID"`\n		CommentParent int    `json:"commentParent"`\n		CommentBody   string `json:"commentBody"`\n		CommenterID   string `json:"commenterID"`\n	}{\n		Action:        "commentCreationBroadcast",\n		CommentID:     commentID,\n		CommentParent: noParentSafe,\n		CommentBody:   *data.CommentBody,\n		CommenterID:   data.InvokerID,\n	})\n\n	if err != nil {\n		log.Printf("Failed to create JSON message: %v", err)\n		return\n	}\n	broadcast(jsonMsg, broadcastTargets)\n}\n\nfunc commentUpdate(data Data) {\n	const query = `UPDATE Comment SET body = ?, edited = ? WHERE id = ?`\n	params := []interface{}{\n		data.CommentBody,\n		true,\n		data.CommentID,\n	}\n	_, err := db.Exec(query, params...)\n	if err != nil {\n		log.Printf("Failed to execute query: %v", err)\n		return\n	}\n	broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n	jsonMsg, err := json.Marshal(&amp;struct {\n		Action      string `json:"action"`\n		CommentID   int    `json:"commentID"`\n		CommentBody string `json:"commentBody"`\n	}{\n		Action:      "commentUpdateBroadcast",\n		CommentID:   *data.CommentID,\n		CommentBody: *data.CommentBody,\n	})\n\n	if err != nil {\n		log.Printf("Failed to create JSON message: %v", err)\n		return\n	}\n	broadcast(jsonMsg, broadcastTargets)\n}\n\nfunc commentDeletion(data Data) {\n	if *data.DeleteType == "user" || (*data.DeleteType == "admin" &amp;&amp; data.InvokerID == os.Getenv("ADMIN_ID")) {\n		var params []interface{}\n		var query string\n		deletionBody := fmt.Sprintf("[comment removed by %s]", *data.DeleteType)\n\n		if *data.DeleteType == "user" {\n			query = `UPDATE Comment SET body = ?, edited = ? WHERE id = ?`\n			params = []interface{}{\n				deletionBody,\n				false,\n				data.CommentID,\n			}\n		} else {\n			query = `UPDATE Comment SET body = ?, edited = ?, commenter_id = ? WHERE id = ?`\n			params = []interface{}{\n				deletionBody,\n				false,\n				0,\n				data.CommentID,\n			}\n		}\n		_, err := db.Exec(query, params...)\n		if err != nil {\n			log.Printf("Failed to execute query: %v", err)\n			return\n		}\n\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action      string `json:"action"`\n			CommentID   int    `json:"commentID"`\n			CommentBody string `json:"commentBody"`\n		}{\n			Action:      "commentDeletionBroadcast",\n			CommentID:   *data.CommentID,\n			CommentBody: deletionBody,\n		})\n\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	} else if *data.DeleteType == "full" {\n		query := `DELETE FROM Comment WHERE id = ?`\n		_, err := db.Exec(query, data.CommentID)\n		if err != nil {\n			log.Printf("Failed to execute query %v", err)\n			return\n		}\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action    string `json:"action"`\n			CommentID int    `json:"commentID"`\n		}{\n			Action:    "commentDeletionBroadcast",\n			CommentID: *data.CommentID,\n		})\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	}\n}\n\nfunc commentReaction(data Data) {\n	if *data.Reaction == "upVote" || *data.Reaction == "downVote" {\n		commentPoints(data)\n	} else {\n		//first delete\n		deleteQuery := `DELETE FROM CommentReaction WHERE type = ? AND comment_id = ? AND user_id = ?`\n		params := []interface{}{\n			*data.Reaction,\n			*data.CommentID,\n			data.InvokerID,\n		}\n		res, err := db.Exec(deleteQuery, params...)\n		if err != nil {\n			log.Printf("Failed to execute query: %v", err)\n			return\n		}\n		affectedRows, err := res.RowsAffected()\n		if err != nil {\n			log.Printf("Failed to get affected row count: %v", err)\n			return\n		}\n		var endEffect = "deletion"\n		if affectedRows == 0 {\n			insertQuery := `INSERT INTO CommentReaction (type, comment_id, user_id) VALUES (?, ?, ?)`\n			_, err := db.Exec(insertQuery, params...)\n			if err != nil {\n				log.Printf("Failed to get affected row count: %v", err)\n				return\n			}\n			endEffect = "creation"\n		}\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action         string `json:"action"`\n			ReactionType   string `json:"reactionType"`\n			EndEffect      string `json:"endEffect"`\n			ReactingUserID string `json:"reactingUserID"`\n			CommentID      int    `json:"commentID"`\n		}{\n			Action:         "commentReactionBroadcast",\n			ReactionType:   *data.Reaction,\n			EndEffect:      endEffect,\n			ReactingUserID: data.InvokerID,\n			CommentID:      *data.CommentID,\n		})\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	}\n}\n\nfunc commentPoints(data Data) {\n	deleteQuery := `DELETE FROM CommentReaction WHERE type = ? AND comment_id = ? AND user_id = ?`\n	insertQuery := `INSERT INTO CommentReaction (type, comment_id, user_id) VALUES (?, ?, ?)`\n	upVoteParams := []interface{}{\n		"upVote",\n		*data.CommentID,\n		data.InvokerID,\n	}\n	downVoteParams := []interface{}{\n		"downVote",\n		*data.CommentID,\n		data.InvokerID,\n	}\n	localBroadcaster := func(endEffect string) {\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action         string `json:"action"`\n			ReactionType   string `json:"reactionType"`\n			EndEffect      string `json:"endEffect"`\n			ReactingUserID string `json:"reactingUserID"`\n			CommentID      int    `json:"commentID"`\n		}{\n			Action:         "commentReactionBroadcast",\n			ReactionType:   *data.Reaction,\n			EndEffect:      endEffect,\n			ReactingUserID: data.InvokerID,\n			CommentID:      *data.CommentID,\n		})\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	}\n\n	if *data.Reaction == "upVote" {\n		//start with delete upVote, if a deletion was done, all good, broadcast it\n		//if not, delete a downVote (may or may not exist), and create an upVote. broadcast\n		res, err := db.Exec(deleteQuery, upVoteParams...)\n		if err != nil {\n			log.Printf("Failed to execute query 0: %v", err)\n			return\n		}\n		affectedRows, err := res.RowsAffected()\n		if err != nil {\n			log.Printf("Failed to get affected row count: %v", err)\n			return\n		}\n		if affectedRows == 0 {\n			//delete downVote\n			res2, deleteErr := db.Exec(deleteQuery, downVoteParams...)\n			if deleteErr != nil {\n				log.Printf("Failed to execute query 1: %v", err)\n				return\n			}\n			affectedRows, err := res2.RowsAffected()\n			if err != nil {\n				log.Printf("Failed to get affected row count: %v", err)\n				return\n			}\n			_, createErr := db.Exec(insertQuery, upVoteParams...)\n			if createErr != nil {\n				log.Printf("Failed to execute query 2: %v", createErr)\n				return\n			}\n			endEffect := "inversion"\n			if affectedRows == 0 {\n				endEffect = "creation"\n			}\n			localBroadcaster(endEffect)\n\n		} else {\n			//user already had upVote given, and reclicked upVote button (return to neutral)\n			localBroadcaster("deletion")\n		}\n	} else if *data.Reaction == "downVote" {\n		//repeat same as above, but with downVote type\n		res, err := db.Exec(deleteQuery, downVoteParams...)\n		if err != nil {\n			log.Printf("Failed to execute query 3: %v", err)\n			return\n		}\n		affectedRows, err := res.RowsAffected()\n		if err != nil {\n			log.Printf("Failed to get affected row count: %v", err)\n			return\n		}\n		if affectedRows == 0 {\n			res2, deleteErr := db.Exec(deleteQuery, upVoteParams...)\n			if deleteErr != nil {\n				log.Printf("Failed to execute query 4: %v", deleteErr)\n				return\n			}\n			affectedRows, err := res2.RowsAffected()\n			if err != nil {\n				log.Printf("Failed to get affected row count: %v", err)\n				return\n			}\n			_, createErr := db.Exec(insertQuery, downVoteParams...)\n			if createErr != nil {\n				log.Printf("Failed to execute query 5: %v", createErr)\n				return\n			}\n			endEffect := "inversion"\n			if affectedRows == 0 {\n				endEffect = "creation"\n			}\n			localBroadcaster(endEffect)\n		} else {\n			//user already had downVote given, and reclicked downVote button (return to neutral)\n			localBroadcaster("deletion")\n		}\n	}\n}\n\nfunc postLike(data Data) {\n	alreadyLikedCheckQuery := fmt.Sprintf(`DELETE FROM %sLike WHERE user_id = ?, AND %s_id = ?`, strings.Title(data.PostType), data.PostType)\n	params := []interface{}{\n		data.InvokerID,\n		data.PostID,\n	}\n	res, err := db.Exec(alreadyLikedCheckQuery, params...)\n	if err != nil {\n		log.Printf("Failed to execute query: %v", err)\n		return\n	}\n	affectedRows, err := res.RowsAffected()\n	if err != nil {\n		log.Printf("Failed to get affected row count: %v", err)\n		return\n	}\n	if affectedRows == 0 {\n		//add new postLike\n		query := fmt.Sprintf(`INSERT INTO %sLike (user_id, %s_id) VALUES (?, ?)`, strings.Title(data.PostType), data.PostType)\n		params := []interface{}{\n			data.InvokerID,\n			data.PostID,\n		}\n		_, err := db.Exec(query, params...)\n		if err != nil {\n			log.Printf("Failed to execute query: %v", err)\n			return\n		}\n		//broadcast increment\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action  string `json:"action"`\n			LikerID string `json:"likerID"`\n			Change  int    `json:"change"`\n		}{\n			Action:  "postLikeBroadcast",\n			LikerID: data.InvokerID,\n			Change:  1,\n		})\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	} else {\n		//broadcast decrement\n		broadcastTargets := getAllConnectionsInChannel(*data.PostID, data.PostType)\n		jsonMsg, err := json.Marshal(&amp;struct {\n			Action  string `json:"action"`\n			LikerID string `json:"likerID"`\n			Change  int    `json:"change"`\n		}{\n			Action:  "postLikeBroadcast",\n			LikerID: data.InvokerID,\n			Change:  -1,\n		})\n		if err != nil {\n			log.Printf("Failed to create JSON message: %v", err)\n			return\n		}\n		broadcast(jsonMsg, broadcastTargets)\n	}\n\n}\n\nfunc reader(client *Client) {\n	for {\n		messageType, p, err := client.Conn.ReadMessage()\n		if err != nil {\n			lock.Lock()\n			delete(clients, client.ID)\n			lock.Unlock()\n\n			client.Conn.Close()\n			log.Println(err)\n			return\n		}\n		jsonData := string(p)\n		var data Data\n\n		parse_err := json.Unmarshal([]byte(jsonData), &amp;data)\n		if parse_err != nil {\n			log.Printf("Error occurred during unmarshaling. Error: %s", err.Error())\n		}\n\n		log.Println(data.Action)\n\n		switch data.Action {\n		case "channelUpdate":\n			channelUpdate(data, client)\n		case "commentCreation":\n			commentCreation(data)\n		case "commentUpdate":\n			commentUpdate(data)\n		case "commentDeletion":\n			commentDeletion(data)\n		case "commentReaction":\n			commentReaction(data)\n		case "postLike":\n			postLike(data)\n		default:\n			log.Printf("Unrecognized action: %s", data.Action)\n		}\n\n		if err := client.Conn.WriteMessage(messageType, p); err != nil {\n			log.Println(err)\n			return\n		}\n	}\n}\n\nfunc wsEndpoint(writer http.ResponseWriter, req *http.Request) {\n	upgrader.CheckOrigin = func(req *http.Request) bool { return true }\n\n	ws, err := upgrader.Upgrade(writer, req, nil)\n	if err != nil {\n		log.Println(err)\n	}\n	client := &amp;Client{\n		ID:   uuid.New().String(),\n		Conn: ws,\n	}\n	lock.Lock()\n	clients[client.ID] = client\n	lock.Unlock()\n	reader(client)\n}\n\nfunc setupRoutes() {\n	http.HandleFunc("/", wsEndpoint)\n}\n\nfunc main() {\n	db = createDBConnection()\n	defer db.Close()\n	setupRoutes()\n\n	err := godotenv.Load()\n	if err != nil {\n		log.Printf("Error loading .env file")\n	}\n	port := os.Getenv("PORT")\n	if port == "" {\n		port = "8080" // Default port if not specified\n	}\n	log.Fatal(http.ListenAndServe(":"+port, nil))\n\n}</code></pre>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/project/Serverless is kinda booty.../golang-ws-code.jpg','2023-11-02 22:29:43',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTcwMzg3MTAwNSwiZXhwIjoxNzA1MDgwNjA1fQ.DM8N9Yk1kqY2yUclYBVUnqMBJZLQmZqumOnsNpBGkQ0',47,NULL);
INSERT INTO Post VALUES(13,'Shapes_With_Abigail!','I Created A Kids Game',replace('<p><strong><em>A Quick Side Project</em></strong></p><p>I have been working on a mobile game for the past 6 or so weeks and took a quick break to create another game mainly for my girlfriends nephew(a 3 year-old). I had previously intended to so a few months back but got caught up with other things.</p><p>The original imputus for creating the app was a night out with my girlfriends sister''s family, my girlfriends nephew was being a fuss, he had previously played a game on her phone, and kept asking to play it by repeatedly asking, "Shapes with Abigail?". We tried a few other games and they were all litered with either ads or walls asking for microtransactions, so I wanted to make something simple that didn''t have any of that.</p><p>After getting some experience with react native on the aformentioned mobile game I felt I could throw together something quickly. The total project took ~2 weeks, most of which was spent in getting it ready and on the app stores(still only on the <a target="_blank" rel="noopener noreferrer nofollow" href="https://apps.apple.com/us/app/shapes-with-abigail/id6474561117">Apple app store</a>), but the apk(for android) is available <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/downloads">here</a>.</p><p>The game it self is rather simple either matching shapes, simple math problems, or spelling words given an image.</p><img src="https://frenomeimages.s3.amazonaws.com/project/Shapes_With_Abigail!/800x400bb-1.png"><img src="https://frenomeimages.s3.amazonaws.com/project/Shapes_With_Abigail!/800x400bb.png"><img src="https://frenomeimages.s3.amazonaws.com/project/Shapes_With_Abigail!/800x400bb-2.png"><p>There aren''t a ton of each type of problem around 50 shape sets, 30 math and words. The making of the problems however is super easy and will add more later. They are stored in a JSON file and look like this for shape sets:</p><pre><code class="language-json">...  \n  [\n    {\n      "svg": "triangle",\n      "size": 65,\n      "color": "#a3e635",\n      "shifts": "y",\n      "targetX": 12,\n      "targetY": 20\n    },\n    {\n      "svg": "triangle",\n      "shifts": "x",\n      "size": 85,\n      "color": "#a3e635",\n      "targetX": 0,\n      "targetY": 40\n    },\n    {\n      "svg": "triangle",\n      "shifts": "y",\n      "size": 120,\n      "color": "#a3e635",\n      "targetX": -20,\n      "targetY": 60\n    }\n  ],\n...</code></pre><p>Or like this for numbers:</p><pre><code class="language-json">  ...\n  {\n    "operation": "addition",\n    "operands": ["nine", "nine"],\n    "result": "eighteen",\n    "otherOptions": ["seventeen", "nineteen", "sixteen"]\n  },\n  {\n    "operation": "subtraction",\n    "operands": ["nine", "one"],\n    "result": "eight",\n    "otherOptions": ["seven", "six", "nine"]\n  },\n...</code></pre><p>The words are a little more time consuming as I need an image to use, so that probably not be expanded as much in future.</p><p>The project was immedietly useful for my other game, as I learned about making draggable assets and hit detection. It''s a tad more refined in my other game, but here is how its done in Shapes with Abigail in the simplest case.</p><pre><code class="language-typescript">   const positionChecker = (movableX: number, movableY: number) =&gt; {\n    targetRef.current?.measureInWindow(\n      (targetX, targetY, targetWidth, targetHeight) =&gt; {\n        const overLapRequired = targetWidth * 0.3;\n\n        const isWidthAligned =\n          movableX + componentSizing / 2 - overLapRequired &gt;= targetX &amp;&amp;\n          movableX - componentSizing / 2 + overLapRequired &lt;=\n            targetX + targetWidth;\n        const isHeightAligned =\n          movableY +\n            componentSizing / 2 -\n            overLapRequired -\n            (Platform.OS == "android" ? 40 : 0) &gt;=\n            targetY &amp;&amp;\n          movableY -\n            componentSizing / 2 +\n            overLapRequired -\n            (Platform.OS == "android" ? 60 : 0) &lt;=\n            targetY + targetHeight;\n\n        if (isWidthAligned &amp;&amp; isHeightAligned &amp;&amp; notAligned) {\n          vibrate({ style: "medium", onAndroid: true });\n          setNotAligned(false);\n          Animated.parallel([\n            Animated.timing(fadeAnim, {\n              toValue: 0,\n              duration: 1500,\n              useNativeDriver: true,\n            }),\n            Animated.timing(scaleAnim, {\n              toValue: 1.5,\n              duration: 1500,\n              useNativeDriver: true,\n            }),\n          ]).start(() =&gt; {\n            //this fires at animation completion\n            gameRestart();\n          });\n        }\n      },\n    );\n  };</code></pre><p>For whatever reason Android devices had a weird issue with the collision detection that needed a correction that was quite ugly to have.</p><p>As for how this is triggered:</p><pre><code class="language-typescript">  return(\n...\n      &lt;View className="flex h-24 flex-row justify-center"&gt;\n          {movableNumbers.map((movableNumber, idx) =&gt; {\n            return (\n              &lt;View\n                className={`ml-16 ${\n                  !notAligned &amp;&amp; movableNumber.correctResult ? "opacity-0" : ""\n                } ${\n                  movableNumber.Component &amp;&amp; movableNumber.Component.length &gt; 1\n                    ? "mr-28"\n                    : "mr-16"\n                }`}\n                key={movableNumber.id + movableNumber.color + idx}\n              &gt;\n                &lt;Draggable\n                  onDrag={\n                    movableNumber.correctResult\n                      ? (_, g) =&gt; positionChecker(g.moveX, g.moveY)\n                      : undefined\n                  }\n                  shouldReverse\n                &gt;\n                  &lt;View className="flex flex-row"&gt;\n                    {movableNumber.Component &amp;&amp;\n                      movableNumber.Component.map((Comp, key) =&gt; (\n                        &lt;Comp\n                          key={key}\n                          width={componentSizing - 30}\n                          height={componentSizing}\n                          color={movableNumber.color}\n                        /&gt;\n                      ))}\n                  &lt;/View&gt;\n                &lt;/Draggable&gt;\n              &lt;/View&gt;\n            );\n          })}\n        &lt;/View&gt;\n...\n)</code></pre><p>An array of Draggables(<a target="_blank" rel="noopener noreferrer nofollow" href="https://www.npmjs.com/package/react-native-draggable">https://www.npmjs.com/package/react-native-draggable</a>) is rendered, only the correct answer actually fires the function when being dragged (fired every frame), providing the function with the top left point(x,y) of the Draggable at that frame.</p><p>Anyway this project was super fun quick thing to make that turned out to be super useful in another project, and as with all things, the same logic was implemented much more cleanly and effectively the second time. You may think the above wasnt bad, which it wasn''t terrible, the other modes position checker is a biiit uglier.</p>','\n',char(10)),'https://frenomeimages.s3.amazonaws.com/project/Shapes With Abigail!/800x400bb.png','2023-12-29 17:34:50',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTcwMzg3MTAwNSwiZXhwIjoxNzA1MDgwNjA1fQ.DM8N9Yk1kqY2yUclYBVUnqMBJZLQmZqumOnsNpBGkQ0',50,NULL);
INSERT INTO Post VALUES(14,'I_made_a_macOS_app_in_a_day','(so donâ€™t expect much)','<p><strong><em>Itâ€™s nothing much</em></strong></p><p>The app is a simple stopwatch for the menubar. I made it to help in my work. Thats all. You can download it <a target="_blank" rel="noopener noreferrer nofollow" href="https://www.freno.me/downloads">here</a>. Itâ€™s called Cork.</p><p>Iâ€™ve never written in swift before. Probably wonâ€™t again. Not for the language, but because Xcode is bottom of the barrel garbage, I wouldnâ€™t wish that IDE on anyone.</p>','https://frenomeimages.s3.amazonaws.com/project/I made a macOS app in a day/Screenshot 2024-02-20 at 6.37.41â€¯PM.jpg','2024-02-20 23:40:31',1,'project','eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImVlMzJmZTY4LWY0MGUtNDFhNC05ZmIxLWRkODNlMjRiYjM4NiIsImlhdCI6MTcwODQ3MjE0NCwiZXhwIjoxNzA5NjgxNzQ0fQ.Ad6Kqame2TuZCPKiu6iuUrgPReuiPzos7fZJZTNdf6Y',18,NULL);
CREATE TABLE `PostLike` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `user_id` varchar(255) NOT NULL
,  `post_id` integer NOT NULL
,  UNIQUE (`user_id`,`post_id`)
);
INSERT INTO PostLike VALUES(1,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386',1);
INSERT INTO PostLike VALUES(2,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386',7);
INSERT INTO PostLike VALUES(3,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386',10);
INSERT INTO PostLike VALUES(4,'ee32fe68-f40e-41a4-9fb1-dd83e24bb386',5);
INSERT INTO PostLike VALUES(5,'9978c028-7c29-4fec-a3fb-c274511c9983',7);
CREATE TABLE `Tag` (
  `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT
,  `value` varchar(255) NOT NULL
,  `post_id` integer NOT NULL
);
INSERT INTO Tag VALUES(4,'#OCaml',6);
INSERT INTO Tag VALUES(5,'#FP',6);
INSERT INTO Tag VALUES(6,'#programming',6);
INSERT INTO Tag VALUES(21,'#vim',7);
INSERT INTO Tag VALUES(22,'#programming',7);
INSERT INTO Tag VALUES(23,'#tools',7);
INSERT INTO Tag VALUES(545,'#bitcoin',8);
INSERT INTO Tag VALUES(546,'#money',8);
INSERT INTO Tag VALUES(547,'#energy',8);
INSERT INTO Tag VALUES(710,'#Weave',1);
INSERT INTO Tag VALUES(711,'#typescript',1);
INSERT INTO Tag VALUES(712,'#websockets',1);
INSERT INTO Tag VALUES(713,'#react',1);
INSERT INTO Tag VALUES(722,'#Weave',3);
INSERT INTO Tag VALUES(723,'#typescript',3);
INSERT INTO Tag VALUES(724,'#react',3);
INSERT INTO Tag VALUES(725,'#WebRTC',3);
INSERT INTO Tag VALUES(726,'#prisma',3);
INSERT INTO Tag VALUES(727,'#lambda',3);
INSERT INTO Tag VALUES(728,'#websockets',3);
INSERT INTO Tag VALUES(729,'#OCaml',4);
INSERT INTO Tag VALUES(730,'#library',4);
INSERT INTO Tag VALUES(731,'#typescript',5);
INSERT INTO Tag VALUES(732,'#Weave',5);
INSERT INTO Tag VALUES(733,'#retrospective',5);
INSERT INTO Tag VALUES(1213,'#app',13);
INSERT INTO Tag VALUES(1214,'#mobile',13);
INSERT INTO Tag VALUES(1215,'#react-native',13);
INSERT INTO Tag VALUES(1216,'#ios',13);
INSERT INTO Tag VALUES(1217,'#android',13);
INSERT INTO Tag VALUES(1218,'#serverless',10);
INSERT INTO Tag VALUES(1219,'#docker',10);
INSERT INTO Tag VALUES(1220,'#golang',10);
INSERT INTO Tag VALUES(1221,'#typescript',10);
INSERT INTO Tag VALUES(1223,'#hardware',9);
INSERT INTO Tag VALUES(1230,'#macOS',14);
INSERT INTO Tag VALUES(1231,'#app',14);
INSERT INTO Tag VALUES(1232,'#programming',14);
CREATE TABLE `User` (
  `id` varchar(255) NOT NULL
,  `email` varchar(255) DEFAULT NULL
,  `password_hash` varchar(255) DEFAULT NULL
,  `image` varchar(255) DEFAULT NULL
,  `registered_at` datetime NOT NULL DEFAULT current_timestamp
,  `display_name` varchar(255) DEFAULT NULL
,  `provider` varchar(255) DEFAULT NULL
,  `email_verified` integer DEFAULT NULL
,  PRIMARY KEY (`id`)
,  UNIQUE (`email`)
);
INSERT INTO User VALUES('2083e7f5-4b81-4ec8-8a0b-97b00bce99b3',NULL,NULL,NULL,'2023-07-22 02:12:43',NULL,'github',NULL);
INSERT INTO User VALUES('2cbae796-582e-49de-83b1-b9fe13a4c04a',NULL,NULL,'https://avatars.githubusercontent.com/u/108227314?v=4','2023-07-19 13:53:00','MikeFreno','github',NULL);
INSERT INTO User VALUES('7fab8143-4def-41f2-bfa3-1d477314426e',NULL,NULL,NULL,'2024-03-07 23:06:28',NULL,'google',NULL);
INSERT INTO User VALUES('9978c028-7c29-4fec-a3fb-c274511c9983','michaelt.freno@gmail.com','$2b$10$0tcjDFI8eIkATkEx/PH3u.iC2.kAKicxIBOrkSMIkmQjBSyRJ6v7a','https://lh3.googleusercontent.com/a/AAcHTtdiifn-XSo0iW1jNr6vc-jhXPzPkZmiE_PlTAw0tHe8_hE=s96-c','2023-07-22 03:00:00','Michael Freno','google',1);
INSERT INTO User VALUES('a49fb8ca-b32a-4fb9-8c2e-a1b7b7868315',NULL,NULL,NULL,'2023-07-20 11:55:32','user deleted',NULL,0);
INSERT INTO User VALUES('a76a53d8-ae71-47fd-a235-b4e72156b2c1','frenox19@gmail.com','$2b$10$Bho4b9n3Mkd31HyMyit3T.CsFJaZAffhEDyCCRk5fL7QGleUG5tFO','https://frenomeimages.s3.amazonaws.com/user/a76a53d8-ae71-47fd-a235-b4e72156b2c1/000063480029.png','2023-07-20 23:44:29',NULL,NULL,1);
INSERT INTO User VALUES('babe7128-e28a-4364-9ef9-e2f9bd228374',NULL,NULL,NULL,'2023-07-22 02:14:54',NULL,'github',NULL);
INSERT INTO User VALUES('e521df61-d650-4e0f-a1dd-4874a5d365c1',NULL,NULL,NULL,'2024-03-07 23:13:41',NULL,'google',NULL);
INSERT INTO User VALUES('ee32fe68-f40e-41a4-9fb1-dd83e24bb386','michael@freno.me','$2b$10$G/H.VDFIUpKpXVyYipZG0.ksu.uJv.o0JfZji2eCQV7jo9BrKV7Nm','https://frenomeimages.s3.amazonaws.com/user/ee32fe68-f40e-41a4-9fb1-dd83e24bb386/000138510003.jpg','2023-07-09 19:00:42','Mike',NULL,1);
DELETE FROM sqlite_sequence;
INSERT INTO sqlite_sequence VALUES('CommentReaction',29);
INSERT INTO sqlite_sequence VALUES('Post',14);
INSERT INTO sqlite_sequence VALUES('PostLike',5);
INSERT INTO sqlite_sequence VALUES('Tag',1232);
CREATE INDEX "idx_PostLike_post_id" ON "PostLike" (`post_id`);
CREATE INDEX "idx_CommentReaction_comment_id" ON "CommentReaction" (`comment_id`);
CREATE INDEX "idx_Post_category" ON "Post" (`category`);
CREATE INDEX "idx_Post_idx_post_title_cat_pub_likes" ON "Post" (`title`,`category`,`published`);
CREATE INDEX "idx_Tag_post_id" ON "Tag" (`post_id`);
CREATE INDEX "idx_Comment_commenter_id" ON "Comment" (`commenter_id`);
CREATE INDEX "idx_Comment_parent_comment_id" ON "Comment" (`parent_comment_id`);
CREATE INDEX "idx_Comment_post_id" ON "Comment" (`post_id`);
CREATE INDEX "idx_Connection_post_id" ON "Connection" (`post_id`);
COMMIT;
